<!DOCTYPE html>

<html>
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Basic Tools</title>
<link href="../static/favicon.ico" rel="icon" type="image/x-icon"/>
<link href="../static/mccole.css" rel="stylesheet" type="text/css"/>
<script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
<nav>
<a href="../">Home</a>
      ·
      <span class="dropdown">
<a href="#">Lessons</a>
<span class="dropdown-content">
<a href="../01_intro/">Introduction</a>
<a href="../02_meeting/">How to Run a Meeting</a>
<a href="../03_gst/">Goals, Strategies, and Tactics</a>
<a href="../04_power/">Power</a>
<a href="../05_start/">Starting</a>
<a href="../06_finish/">Finishing</a>
</span>
</span>
      ·
      <span class="dropdown">
<a href="#">Extras</a>
<span class="dropdown-content">
<a href="../license/">License</a>
<a href="../conduct/">Code of Conduct</a>
<a href="../bibliography/">Bibliography</a>
<a href="../glossary/">Glossary</a>
</span>
</span>
</nav>
<main>
<h1>Basic Tools</h1>
<ul>
<li>Motivating problem: how big is the average Python package?<ul>
<li>What do we mean by "big"?<ul>
<li>Count lines and characters for now</li>
</ul>
</li>
<li>What do we mean by "average"?<ul>
<li>Analyze the packages on this computer to start</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>How can we get some data?</h2>
<ul>
<li>Where is Python installed?</li>
</ul>
<pre><code class="language-py">import sys
print('\n'.join(sys.path))
</code></pre>
<pre><code class="language-txt">
/anaconda3/lib/python37.zip
/anaconda3/lib/python3.7
/anaconda3/lib/python3.7/lib-dynload
/anaconda3/lib/python3.7/site-packages
</code></pre>
<ul>
<li>The blank at the start is the empty string, which means "current directory"</li>
<li>Use the shell to find and display Python file sizes</li>
</ul>
<pre><code class="language-sh">find /anaconda3 -name '*.py' -exec wc -l -c {} \;
</code></pre>
<pre><code class="language-txt">      27     877 /anaconda3/bin/rst2xetex.py
      26     797 /anaconda3/bin/rst2latex.py
      67    1704 /anaconda3/bin/rst2odt_prepstyles.py
      26     720 /anaconda3/bin/rst2html4.py
      35    1145 /anaconda3/bin/rst2html5.py
...
</code></pre>
<ul>
<li>We could convert this output to <span g="csv">comma-separated values</span> (CSV) with command-line tools like [awk][awk] or [sed][sed]<ul>
<li>But since we're using Python anyway...</li>
</ul>
</li>
</ul>
<pre><code class="language-py">import sys

print('Lines,Characters,Path')
for line in sys.stdin:
    fields = line.split()
    print('{},{},{}'.format(*fields))
</code></pre>
<p>{: title="wc2csv.py"}</p>
<ul>
<li>Run it as shown below<ul>
<li>Break lines to make commands more visible (and to prevent long lines)</li>
</ul>
</li>
</ul>
<pre><code class="language-sh">find /anaconda3 -name '*.py' -exec wc -l -c {} \; \
  | python wc2csv.py \
  &gt; python-local-package-size.csv
cat python-local-package-size.csv
</code></pre>
<pre><code class="language-txt">Lines,Characters,Path
27,877,/anaconda3/bin/rst2xetex.py
26,797,/anaconda3/bin/rst2latex.py
67,1704,/anaconda3/bin/rst2odt_prepstyles.py
26,720,/anaconda3/bin/rst2html4.py
35,1145,/anaconda3/bin/rst2html5.py
...
</code></pre>
<ul>
<li>This is <span g="tidy_data">tidy data</span><ol>
<li>Each column contains one statistical variable
    (i.e., one property that was measured or observed)</li>
<li>Each different observation is in a different row</li>
<li>There is one table for each set of observations</li>
<li>If there are multiple tables,
    each table has a column containing a unique <span g="key">key</span>
    so that related data can be linked</li>
</ol>
</li>
</ul>
<h2>How can we analyze tabular data?</h2>
<ul>
<li>There's a lot of tabular data in the world</li>
<li>People want to do a lot of complex things with it, so Python's tools can be bewildering at first<ol>
<li>Built-in lists and the <code>array</code> module</li>
<li>[NumPy][numpy] provides multidimensional arrays</li>
<li>[Pandas][pandas] provides <span g="dataframe">dataframes</span> with named columns for tidy data</li>
</ol>
</li>
<li>We will use a small subset of Pandas<ul>
<li>Gives us tables whose columns can have different datatypes</li>
<li>Access columns by name</li>
<li>Access rows by index</li>
</ul>
</li>
<li>Load our CSV data into memory and have a look</li>
</ul>
<pre><code class="language-py">import pandas

data = pandas.read_csv('python-local-package-size.csv')
print(data)
</code></pre>
<p>{: title="pandas-read-display.py"}</p>
<pre><code class="language-txt">       Lines  Characters                                               Path
0         27         877                        /anaconda3/bin/rst2xetex.py
1         26         797                        /anaconda3/bin/rst2latex.py
2         67        1704               /anaconda3/bin/rst2odt_prepstyles.py
...
33243    256       10135  /anaconda3/share/glib-2.0/codegen/codegen_main.py
33244    431       17774     /anaconda3/share/glib-2.0/codegen/dbustypes.py
33245   3469      206544       /anaconda3/share/glib-2.0/codegen/codegen.py

[33246 rows x 3 columns]
</code></pre>
<ul>
<li>The <span g="header_row">header row</span> tells us the names of the columns</li>
<li>We can get these names using the dataframe's <code>columns</code> <span g="property">property</span><ul>
<li>Not a method call</li>
</ul>
</li>
</ul>
<pre><code class="language-py">print(data.columns)
</code></pre>
<p>{: title="pandas-read-display.py"}</p>
<pre><code class="language-txt">Index(['Lines', 'Characters', 'Path'], dtype='object')
</code></pre>
<ul>
<li>Result is an <code>Index</code> object containing the columns' names and other information</li>
<li>Its <code>values</code> property contains just the names</li>
</ul>
<pre><code class="language-py">print(data.columns.values)
</code></pre>
<p>{: title="pandas-read-display.py"}</p>
<pre><code class="language-txt">['Lines' 'Characters' 'Path']
</code></pre>
<ul>
<li>We normally import Pandas using an <span g="alias">alias</span> called <code>pd</code>
    to save a few characters of typing and (more importantly) make code a little easier to read</li>
<li>Re-load our data that way<ul>
<li>And use a more meaningful name than <code>data</code></li>
<li>Then select a column by name</li>
</ul>
</li>
</ul>
<pre><code class="language-py">import pandas as pd

packages = pd.read_csv('python-local-package-size.csv')
print(packages['Path'])
</code></pre>
<p>{: title="pandas-select-col.py"}</p>
<pre><code class="language-txt">0                              /anaconda3/bin/rst2xetex.py
1                              /anaconda3/bin/rst2latex.py
2                     /anaconda3/bin/rst2odt_prepstyles.py
...
33243    /anaconda3/share/glib-2.0/codegen/codegen_main.py
33244       /anaconda3/share/glib-2.0/codegen/dbustypes.py
33245         /anaconda3/share/glib-2.0/codegen/codegen.py
Name: Path, Length: 33246, dtype: object
</code></pre>
<ul>
<li>The line at the end tells us:<ul>
<li>The name of the column we selected</li>
<li>How many records there are</li>
<li>The column's data type</li>
</ul>
</li>
<li>We can select several columns at once by giving a list of names<ul>
<li>Which results in double square brackets</li>
<li>Outer brackets mean "we're selecting something"</li>
<li>Inner ones means "we're providing a list to specify what we're selecting"</li>
</ul>
</li>
</ul>
<pre><code class="language-py">print(packages[['Lines', 'Characters']])
</code></pre>
<p>{: title="pandas-select-col.py"}</p>
<pre><code class="language-txt">       Lines  Characters
0         27         877
1         26         797
2         67        1704
...
33243    256       10135
33244    431       17774
33245   3469      206544

[33246 rows x 2 columns]
</code></pre>
<ul>
<li>What if we want to select a row?</li>
</ul>
<pre><code class="language-py">print(packages[0])
</code></pre>
<p>{: title="pandas-select-row-fail.py"}</p>
<pre><code class="language-txt">Traceback (most recent call last):
  File "/anaconda3/lib/python3.7/site-packages/pandas/core/indexes/base.py", line 2657, in get_loc
    return self._engine.get_loc(key)
  File "pandas/_libs/index.pyx", line 108, in pandas._libs.index.IndexEngine.get_loc
  File "pandas/_libs/index.pyx", line 132, in pandas._libs.index.IndexEngine.get_loc
  File "pandas/_libs/hashtable_class_helper.pxi", line 1601, in pandas._libs.hashtable.PyObjectHashTable.get_item
  File "pandas/_libs/hashtable_class_helper.pxi", line 1608, in pandas._libs.hashtable.PyObjectHashTable.get_item
KeyError: 0

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "pandas-select-row-fail.py", line 4, in &lt;module&gt;
    print(packages[0])
  File "/anaconda3/lib/python3.7/site-packages/pandas/core/frame.py", line 2927, in __getitem__
    indexer = self.columns.get_loc(key)
  File "/anaconda3/lib/python3.7/site-packages/pandas/core/indexes/base.py", line 2659, in get_loc
    return self._engine.get_loc(self._maybe_cast_indexer(key))
  File "pandas/_libs/index.pyx", line 108, in pandas._libs.index.IndexEngine.get_loc
  File "pandas/_libs/index.pyx", line 132, in pandas._libs.index.IndexEngine.get_loc
  File "pandas/_libs/hashtable_class_helper.pxi", line 1601, in pandas._libs.hashtable.PyObjectHashTable.get_item
  File "pandas/_libs/hashtable_class_helper.pxi", line 1608, in pandas._libs.hashtable.PyObjectHashTable.get_item
KeyError: 0
</code></pre>
<ul>
<li>Pandas error messages aren't particularly readable</li>
<li>Pandas doesn't allow us to select rows by numeric index<ul>
<li>Ambiguous, since <code>1</code> could mean "first column" rather than "first row"</li>
</ul>
</li>
<li>Instead, use a property of the dataframe called <code>iloc</code> (for "indexed location")</li>
</ul>
<pre><code class="language-py">print(packages.iloc[0])
</code></pre>
<p>{: title="pandas-select-row-iloc.py"}</p>
<pre><code class="language-txt">Lines                                  27
Characters                            877
Path          /anaconda3/bin/rst2xetex.py
Name: 0, dtype: object
</code></pre>
<ul>
<li>
<p>Displays a two-column table with keys and values</p>
<ul>
<li>Count from zero (for [surprising reasons][hoye-count-from-zero])</li>
</ul>
</li>
<li>
<p>We can use a <span g="slice">slice</span> to select multiple rows</p>
<ul>
<li><span class="rule">If you're writing a loop to process a table, you're doing something wrong</span></li>
</ul>
</li>
</ul>
<pre><code class="language-py">print(packages.iloc[0:5])
</code></pre>
<p>{: title="pandas-select-row-iloc.py"}</p>
<pre><code class="language-txt">   Lines  Characters                                  Path
0     27         877           /anaconda3/bin/rst2xetex.py
1     26         797           /anaconda3/bin/rst2latex.py
2     67        1704  /anaconda3/bin/rst2odt_prepstyles.py
3     26         720           /anaconda3/bin/rst2html4.py
4     35        1145           /anaconda3/bin/rst2html5.py
</code></pre>
<ul>
<li>We can mix names and numbers to select subsections by column and then row<ul>
<li>Don't need <code>iloc</code> in this case because
    selecting by column gives us back a one-dimensional <code>Series</code> object
    that interprets an integer index the way we want</li>
</ul>
</li>
</ul>
<pre><code class="language-py">print(packages['Characters'][0:3])
</code></pre>
<p>{: title="pandas-select-row-iloc.py"}</p>
<pre><code class="language-txt">0     877
1     797
2    1704
Name: Characters, dtype: int64
</code></pre>
<ul>
<li>Can also select by row and then column using <code>iloc</code><ul>
<li>But indexing out of order makes code harder to read, so don't do this</li>
</ul>
</li>
</ul>
<pre><code class="language-py">print(packages.iloc[0:3]['Characters'])
</code></pre>
<p>{: title="pandas-select-row-iloc.py"}</p>
<pre><code class="language-txt">0     877
1     797
2    1704
Name: Characters, dtype: int64
</code></pre>
<h2>How can we visualize what's in a dataframe?</h2>
<ul>
<li>[<code>matplotlib</code>][matplotlib] is the most widely used plotting module for Python,
    but is fairly low-level</li>
<li>[Plotly Express][plotly] is newer and better suited to creating graphics for browsers<ul>
<li>Usually import using the alias <code>px</code></li>
</ul>
</li>
<li>Use this to create a simple scatter plot<ul>
<li>The figure object's <code>show</code> method runs a local server and opens the image in the browser for viewing</li>
<li>Its <code>write_image</code> method saves it as a file</li>
<li>We put the generated figure in a <code>figures</code> sub-directory to avoid clutter</li>
<li>And use <span g="svg">SVG</span> because <span g="vector_graphics">vector graphics</span> resizes better than <span g="raster_graphics">raster graphics</span></li>
</ul>
</li>
</ul>
<pre><code class="language-py">import pandas as pd
import plotly.express as px

packages = pd.read_csv('python-local-package-size.csv')
fig = px.scatter(packages, x='Lines', y='Characters')
fig.show()
fig.write_image('scatter-lines-characters.svg')
</code></pre>
<p>{: title="scatter-lines-characters.py"}</p>
<p>{% include figure
   id="scatter-lines-characters"
   cap="Characters vs. Lines"
   alt="FIXME"
   title="Scatter plot with most values clustered in the range X equals 0 to 5,000 and Y equals 0 to 0.2 million, with some outliers."
   fixme=true %}</p>
<h2>How can we do calculations with dataframes?</h2>
<ul>
<li>Best way to explore Pandas is by example</li>
<li>Since we don't know what answers to expect from calculations using the package data,
    construct a small example that we can check while we explore</li>
</ul>
<pre><code class="language-py">import pandas as pd

example = pd.DataFrame(data=[[  1,   2,   3],
                             [ 10,  20,  30],
                             [100, 200, 300]],
                       columns=['left', 'middle', 'right'])
print(example)
</code></pre>
<p>{: title="aggregation.py"}</p>
<pre><code class="language-txt">   left  middle  right
0     1       2      3
1    10      20     30
2   100     200    300
</code></pre>
<ul>
<li>Break this down:<ul>
<li><code>pd</code> is the alias for Pandas</li>
<li><code>DataFrame</code> is the kind of object we want to create</li>
<li><code>data</code> is a list-of-lists with the values we want in our dataframe</li>
<li><code>columns</code> is the names we want to give the columns</li>
<li>We could provide <code>data</code> and <code>columns</code> in the opposite order
    and everything would still work
    because we're naming them explicitly</li>
<li>Result is three columns and three rows</li>
</ul>
</li>
<li>We can do arithmetic on entire columns</li>
</ul>
<pre><code class="language-py">print(example['middle'] + example['right'])
</code></pre>
<p>{: title="aggregation.py"}</p>
<pre><code class="language-txt">0      5
1     50
2    500
dtype: int64
</code></pre>
<ul>
<li>If we use a plain old number it is automatically <span g="broadcast">broadcast</span> to the size of the column</li>
</ul>
<pre><code class="language-py">print(7 * example['left'])
</code></pre>
<p>{: title="aggregation.py"}</p>
<pre><code class="language-txt">0      7
1     70
2    700
Name: left, dtype: int64
</code></pre>
<ul>
<li>Sums, averages, and other functions that turn many values into one are called <span g="aggregation">aggregations</span><ul>
<li><code>count</code>: number of elements (excluding <span g="nan"><code>NaN</code></span>)</li>
<li><code>describe</code>: descriptive statistics</li>
<li><code>first</code>: first value</li>
<li><code>last</code>: last value</li>
<li><code>max</code>: largest value</li>
<li><code>mean</code>: average value</li>
<li><code>min</code>: least value</li>
<li><code>nth</code> : \( n^{th} \) value</li>
<li><code>sem</code>: standard error of the mean</li>
<li><code>size</code>: group size (including <code>NaN</code>)</li>
<li><code>std</code>: standard deviation</li>
<li><code>sum</code>: sum of values</li>
<li><code>var</code>: variance</li>
</ul>
</li>
</ul>
<div class="callout">
<h3>Not a Number, Not Available, Null, and None</h3>
<p><code>NaN</code> stands for "Not a Number", a special value used to represent things like
0/0 <cite>Kahan1997</cite>.  Despite the similarity in their names, it is <em>not</em>
the same thing as <span g="na"><code>NA</code></span> (Not Available), which is a
placeholder for missing values.  To make things more confusing, <span g="sql">SQL</span> (the standard language for querying <span g="relational_database">relational databases</span>) uses <span g="null"><code>null</code></span> instead of <code>NA</code> to signal missing data, while many
programming languages use <code>null</code> to mean "a reference that doesn't refer to
anything".  Python uses <code>None</code> instead of <code>null</code>, but we must be careful when
reading and writing data to distinguish between empty strings, missing values,
and the country code for Namibia.</p>
</div>
<ul>
<li>Use the method <code>agg</code> to calculate aggregates<ul>
<li>Give it the name of a function as a string</li>
</ul>
</li>
</ul>
<pre><code class="language-py">print(example.agg('sum'))
</code></pre>
<p>{: title="aggregation.py"}</p>
<pre><code class="language-txt">left      111
middle    222
right     333
dtype: int64
</code></pre>
<ul>
<li>The sum of column <code>left</code> is 111, of column <code>middle</code> is 222, and of <code>right</code> is 333<ul>
<li>Once again <code>dtype</code> is the data type</li>
</ul>
</li>
<li>We can calculate several aggregate values at once by giving <code>DataFrame.agg</code> a list of function names<ul>
<li>Exercise: is this more efficient or not?</li>
</ul>
</li>
</ul>
<pre><code class="language-py">print(example.agg(['sum', 'mean']))
</code></pre>
<p>{: title="aggregation.py"}</p>
<pre><code class="language-txt">       left  middle  right
sum   111.0   222.0  333.0
mean   37.0    74.0  111.0
</code></pre>
<h2>How can we select subsets of data?</h2>
<ul>
<li>Suppose we want to look at the low values in the data</li>
<li>Do this by <span g="filter">filtering</span> data and calculating values for the rows we have kept<ul>
<li>"Keep" would have been a better name than "filter", but we're stuck with it</li>
</ul>
</li>
<li>Create another small dataframe to demonstrate</li>
</ul>
<pre><code class="language-py">import pandas as pd

colors = pd.DataFrame(columns=['name', 'red', 'green', 'blue'],
                      data=[['yellow',  1.0, 1.0, 0.0],
                            ['aqua',    0.0, 1.0, 1.0],
                            ['fuchsia', 1.0, 0.0, 1.0]])
print(colors)
</code></pre>
<p>{: title="filter.py"}</p>
<pre><code class="language-txt">      name  red  green  blue
0   yellow  1.0    1.0   0.0
1     aqua  0.0    1.0   1.0
2  fuchsia  1.0    0.0   1.0
</code></pre>
<ul>
<li>We know how to select the <code>red</code> column</li>
</ul>
<pre><code class="language-py">red = colors['red']
print(red)
</code></pre>
<p>{: title="filter.py"}</p>
<pre><code class="language-txt">0    1.0
1    0.0
2    1.0
Name: red, dtype: float64
</code></pre>
<ul>
<li>Now let's see where values are 1.0 and where they aren't</li>
</ul>
<pre><code class="language-py">has_red = (red == 1.0)
print(has_red)
</code></pre>
<p>{: title="filter.py"}</p>
<pre><code class="language-txt">0     True
1    False
2     True
Name: red, dtype: bool
</code></pre>
<ul>
<li>The expression <code>(red == 1.0)</code> is no different from <code>(red + 3)</code>, except the result is <span g="boolean">Boolean</span> instead of numeric</li>
<li>If we use a Boolean vector as an index, the result is a smaller table containing only the rows where the index was <code>True</code><ul>
<li>But just as we had to use <code>.iloc[...]</code>, we have to use <code>.loc[...]</code> (for "location")</li>
</ul>
</li>
</ul>
<pre><code class="language-py">rows_with_red = colors.loc[has_red]
print(rows_with_red)
</code></pre>
<p>{: title="filter.py"}</p>
<pre><code class="language-txt">      name  red  green  blue
0   yellow  1.0    1.0   0.0
2  fuchsia  1.0    0.0   1.0
</code></pre>
<ul>
<li>So we can calculate the average red, green, and blue for all colors for the whole table:</li>
</ul>
<pre><code class="language-py">print(colors.agg('mean'))
</code></pre>
<p>{: title="filter.py"}</p>
<pre><code class="language-txt">red      0.666667
green    0.666667
blue     0.666667
dtype: float64
</code></pre>
<ul>
<li>Or select only those colors that contain some red and calculate the average for them:</li>
</ul>
<pre><code class="language-py">print(rows_with_red.agg('mean'))
</code></pre>
<p>{: title="filter.py"}</p>
<pre><code class="language-txt">red      1.0
green    0.5
blue     0.5
dtype: float64
</code></pre>
<ul>
<li>Creating temporary variables is unnecessary: we can index the table directly<ul>
<li>Though this can be hard to read because the order of operations doesn't match left-to-right reading order</li>
</ul>
</li>
</ul>
<pre><code class="language-py">print(colors.loc[colors['red'] == 1.0].agg('mean'))
</code></pre>
<p>{: title="filter.py"}</p>
<pre><code class="language-txt">red      1.0
green    0.5
blue     0.5
dtype: float64
</code></pre>
<ul>
<li>This style of programming is called <span g="method_chaining">method chaining</span><ul>
<li>Each operation like <code>loc</code> and <code>agg</code> creates a new object</li>
<li>We immediately call a method of that new object</li>
<li>Then call a method of the object that method returns, and so on</li>
</ul>
</li>
<li>Behind the scenes, Pandas re-uses most of the data rather than copying it to make things faster</li>
</ul>
<h2>How are lines and characters in Python files related?</h2>
<ul>
<li>Created a scatter plot earlier</li>
<li>Construct a <span g="histogram">histogram</span> to see how many <span g="outlier">outliers</span> there are<ul>
<li>Add width and height for the print version</li>
</ul>
</li>
</ul>
<pre><code class="language-py">import pandas as pd
import plotly.express as px

packages = pd.read_csv('python-local-package-size.csv')
packages = packages[packages['Lines'] &gt; 0]
packages['ratio'] = packages['Characters'] / packages['Lines']

fig = px.histogram(packages, x='ratio')
fig.show()
fig.write_image('hist-ratio-unscaled.svg', width=600, height=400)
</code></pre>
<p>{: title="ratio.py"}</p>
<p>{% include figure
   id="hist-ratio-unscaled"
   cap="Ratio of Characters to Lines (Unscaled)"
   alt="FIXME"
   title="Linear-linear histogram with a single sharp spike at X equals 0 going up to Y equals 2,200 and nothing else visible up to X equals 9,000."
   fixme=true %}</p>
<ul>
<li>That's not very informative<ul>
<li>A few large values near x=0</li>
<li>But a few very small values that go up over x=8000</li>
</ul>
</li>
<li>Plot the logarithm of the ratio to show things more clearly <span f="hist-ratio-scaled"></span></li>
</ul>
<pre><code class="language-py">fig = px.histogram(packages, x='ratio', nbins=100, log_y=True)
fig.show()
fig.write_image('hist-ratio-scaled.svg')
</code></pre>
<p>{: title="ratio.py"}</p>
<p>{% include figure
   id="hist-ratio-scaled"
   cap="Ratio of Characters to Lines (Scaled)"
   alt="FIXME"
   title="Log-linear histogram with a single sharp spike at X equals 0 going up to Y equals 3,000 and a sharp decline to Y equals 2 near X equals 1,800 and one outlier of Y equals 2 at X equals 9,000."
   fixme=true %}</p>
<ul>
<li>Play with a threshold for a bit and discover that less than 0.3% of records are above 100 characters per line</li>
<li>Plot all the values except these <em>without</em> logarithmic scaling<ul>
<li>Report how many were excluded so that readers know they're not seeing all the data</li>
</ul>
</li>
</ul>
<pre><code class="language-py">print(f"Excluding {len(packages[packages['ratio'] &gt; 100])}/{len(packages)} data points")
fig = px.histogram(packages[packages['ratio'] &lt;= 100], x='ratio', nbins=100)
fig.show()
fig.write_image('hist-ratio-most.svg')
</code></pre>
<p>{: title="ratio.py"}</p>
<pre><code class="language-txt">Excluding 92 data points
</code></pre>
<p>{% include figure
   id="hist-ratio-most"
   cap="Ratio of Characters to Lines (Most)"
   alt="FIXME"
   title="Linear-linear histogram with apparently normal distribution peaking at Y equals 2200 near X equals 35."
   fixme=true %}</p>
<ul>
<li>Data is easier to see</li>
<li>But what (if anything) does it <em>mean</em>?</li>
<li>For that, we need some statistics</li>
</ul>
<h2>Summary</h2>
<ul>
<li>We have some insights, but we have sinned</li>
<li>Some of our analysis involves manual steps (shell commands that aren't written down anywhere)</li>
<li>Our scripts are not documented<ul>
<li>Which makes life harder for the next person to work on this project</li>
<li>Which will probably be us a few months from now</li>
</ul>
</li>
<li>Data isn't described either<ul>
<li>What does it mean? When and where was it collected?</li>
</ul>
</li>
<li>And our statistics could use some work too<ul>
<li>"Play with the threshold" is a danger sign</li>
</ul>
</li>
<li>In short, this is not <span g="reproducible_research">reproducible research</span></li>
<li>The next few lessons fix these shortcomings</li>
</ul>
</main>
<footer>
<a href="../">Organizational Change for Open Science</a>
      copyright © 2025
      <a href="../01_intro/#acknowledgments">the authors</a>
</footer>
</body>
</html>